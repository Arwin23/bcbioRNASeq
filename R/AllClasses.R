#' bcbioRNASeq Class
#'
#' S4 class containing RNA-seq counts and metadata generated by
#' [bcbio](https://bcbio-nextgen.readthedocs.org).
#'
#' `bcbioRNASeq` extends `RangedSummarizedExperiment` and is designed to store a
#' bcbio RNA-seq analysis. This class contains raw read counts and length-scaled
#' transcripts per million (TPM) generated by [tximport::tximport()]. Counts can
#' be loaded at gene (default) or transcript level.
#'
#' DESeq2 is run automatically when [loadRNASeq()] is called, and variance
#' stabilized counts are slotted into [assays()].
#'
#' The [metadata()] accessor contains:
#'
#' - Sample quality control metrics.
#' - Ensembl annotations.
#' - Server run paths.
#' - R session information (e.g. [utils::sessionInfo()]).
#'
#' @note `bcbioRNASeq` extended `SummarizedExperiment` prior to v0.2.0, where we
#'   migrated to `RangedSummarizedExperiment`.
#'
#' @author Michael Steinbaugh, Lorena Pantano
#' @export
#'
#' @seealso
#' - [loadRNASeq()].
#' - [SummarizedExperiment::SummarizedExperiment()].
#' - `.S4methods(class = "bcbioRNASeq")`.
#'
#' @examples
#' load(system.file("extdata/bcb_small.rda", package = "bcbioRNASeq"))
#' show(bcb_small)
#' validObject(bcb_small)
bcbioRNASeq <- setClass(
    Class = "bcbioRNASeq",
    contains = "RangedSummarizedExperiment"
)



# Validity =====================================================================
setValidity(
    "bcbioRNASeq",
    function(object) {
        assert_is_all_of(object, "SummarizedExperiment")
        assert_has_dimnames(object)

        # Assays ===============================================================
        # Note that `rlog` and `vst` DESeqTransform objects are optional
        assert_is_subset(requiredAssays, assayNames(object))
        # Check that all assays are matrices
        assayCheck <- vapply(
            X = assays(object),
            FUN = is.matrix,
            FUN.VALUE = logical(1L),
            USE.NAMES = TRUE
        )
        if (!all(assayCheck)) {
            abort(paste(
                paste(
                    "Assays that are not matrix:",
                    toString(names(assayCheck[!assayCheck]))
                ),
                updateMsg,
                sep = "\n"
            ))
        }

        # Row data =============================================================
        assert_is_all_of(rowRanges(object), "GRanges")
        assert_is_all_of(rowData(object), "data.frame")
        # Require gene-to-symbol mappings
        assert_is_subset(
            x = c("geneID", "geneName"),
            y = colnames(rowData(object))
        )

        # Column data ==========================================================
        # Check that all of the columns are factors
        colDataCheck <- vapply(
            X = colData(object),
            FUN = is.factor,
            FUN.VALUE = logical(1L),
            USE.NAMES = TRUE
        )
        if (!all(colDataCheck)) {
            abort(paste(
                paste(
                    "Non-factor colData columns:",
                    toString(names(colDataCheck[!colDataCheck]))
                ),
                updateMsg,
                sep = "\n"
            ))
        }

        # Metadata =============================================================
        metadata <- metadata(object)

        # Detect legacy slots
        legacyMetadata <- c(
            "design",
            "ensemblVersion",
            "gtf",
            "gtfFile",
            "missingGenes",
            "programs",
            "yamlFile"
        )
        intersect <- intersect(names(metadata), legacyMetadata)
        if (length(intersect)) {
            abort(paste(
                paste(
                    "Legacy metadata slots:",
                    toString(sort(intersect))
                ),
                updateMsg,
                sep = "\n"
            ))
        }

        # New optional metadata
        # v0.2.0
        # - "loadRNASeq" = "call"
        # - "txdb" = "TxDb"

        # Class checks (order independent)
        requiredMetadata <- list(
            "allSamples" = "logical",
            "bcbioCommandsLog" = "character",
            "bcbioLog" = "character",
            "caller" = "character",
            "countsFromAbundance" = "character",
            "date" = "Date",
            "devtoolsSessionInfo" = "session_info",
            "ensemblRelease" = "integer",
            "genomeBuild" = "character",
            "gffFile" = "character",
            "interestingGroups" = "character",
            "isSpike" = "character",
            "lanes" = "integer",
            "level" = "character",
            "metrics" = "data.frame",
            "organism" = "character",
            "programVersions" = "tbl_df",
            "projectDir" = "character",
            "rowRangesMetadata" = "tbl_df",
            "runDate" = "Date",
            "sampleDirs" = "character",
            "sampleMetadataFile" = "character",
            "template" = "character",
            "tx2gene" = "data.frame",
            "unannotatedRows" = "character",
            "uploadDir" = "character",
            "utilsSessionInfo" = "sessionInfo",
            "version" = "package_version",
            "wd" = "character",
            "yaml" = "list"
        )
        classChecks <- invisible(vapply(
            X = seq_along(requiredMetadata),
            FUN = function(a) {
                name <- names(requiredMetadata)[[a]]
                actual <- class(metadata[[name]])
                expected <- requiredMetadata[[a]]
                if (!length(intersect(expected, actual))) {
                    warn(paste(
                        name, "is not", toString(expected)
                    ))
                    FALSE
                } else {
                    TRUE
                }
            },
            FUN.VALUE = logical(1L),
            USE.NAMES = FALSE
        ))
        if (!all(classChecks)) {
            abort(paste(
                "Metadata class checks failed.", updateMsg, sep = "\n"
            ))
        }

        # Additional assert checks
        # caller
        assert_is_subset(
            x = metadata[["caller"]],
            y = c("salmon", "kallisto", "sailfish")
        )
        # level
        assert_is_subset(
            x = metadata[["level"]],
            y = c("genes", "transcripts")
        )
        # metrics
        metrics <- metadata[["metrics"]]
        assert_are_identical(colnames(object), rownames(metrics))
        assert_are_disjoint_sets(colnames(metrics), legacyMetricsCols)
        # tx2gene
        tx2gene <- metadata[["tx2gene"]]
        assertIsTx2gene(tx2gene)

        TRUE
    }
)
