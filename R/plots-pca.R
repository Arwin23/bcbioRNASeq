#' Sample PCA plot for transformed data
#'
#' Wrapper for [DESeq2::plotPCA()] that improves principal component analysis
#' (PCA) sample coloring and labeling.
#'
#' @param bcb [bcbioRNADataSet].
#' @param transform String specifying [rlog] (**recommended**) or [vst]
#'   [DESeqTransform] slotted inside the [bcbioRNADataSet].
#' @param genes *Optional*. Character vector of gene identifiers to use.
#' @param interesting_groups *Optional*. Interesting groups to use for point
#'   appearance. If `NULL`, color defaults to all `interesting_groups`
#'   parameters set in [bcbioRNADataSet].
#' @param shape *Optional*. Make points easier to inspect with differing shapes.
#' @param label *Optional*. Superimpose sample text labels on the plot.
#'
#' @return PCA plot [ggplot].
#' @examples
#' data(dummy)
#' plot_pca(bcb)
#'
#' @export
#'
#' @seealso [DESeq2::plotPCA()].
plot_pca <- function(
    bcb,
    transform = "rlog",
    genes = NULL,
    interesting_groups = NULL,
    shape = FALSE,
    label = TRUE) {
    if (!transform %in% c("rlog", "vst")) {
        stop("DESeqTransform must be rlog or vst")
    }
    name <- deparse(substitute(dt))
    dt <- assays(bcb)[[transform]]

    # Subset genes, if desired
    if (!is.null(genes)) {
        dt <- dt[genes, ]
        # Set ntop to the number of genes requested
        ntop <- length(genes)
    } else {
        # Recommended DESeq default
        ntop <- 500L
    }

    # Interesting groups
    if (is.null(interesting_groups)) {
        interesting_groups <- metadata(bcb)[["interesting_groups"]]
    }
    interesting_groups_name <- paste(interesting_groups, collapse = " :\n")

    # `group` column is generated by `plotPCA()` using `interesting_groups`
    data <- plotPCA(dt,
                    intgroup = interesting_groups,
                    returnData = TRUE,
                    ntop = ntop) %>% snake
    percent_var <- round(100L * attr(data, "percentVar"))

    # Always define color by `interesting_groups`
    data[["color"]] <- data[["group"]]

    if (isTRUE(shape)) {
        data[["shape"]] <- data[["group"]]
    } else {
        data[["shape"]] <- "default"
    }

    data[["label"]] <- rownames(colData(dt))

    plot <- ggplot(
        data,
        aes_(x = ~pc1,
             y = ~pc2,
             color = ~color,
             shape = ~shape)) +
        geom_point(size = 3L) +
        coord_fixed() +
        labs(title = paste("pca", name, sep = label_sep),
             x = paste0("pc1: ", percent_var[[1L]], "% variance"),
             y = paste0("pc2: ", percent_var[[2L]], "% variance"),
             color = interesting_groups_name,
             shape = interesting_groups_name)

    if (!isTRUE(shape)) {
        plot <- plot + guides(shape = FALSE)
    }

    # Label with sample description, if desired
    if (isTRUE(label)) {
        plot <- plot +
            geom_text_repel(aes_(label = ~label), show.legend = FALSE)
    }

    plot
}



#' Find correlation between principal components (PCs) and covariates.
#'
#' [DEGreport::degCovariates()] wrapper supporting a [bcbioRNADataSet].
#'
#' @author Lorena Pantano
#'
#' @param bcb [bcbioRNADataSet].
#' @param transform String specifying [rlog] (**recommended**) or [vst]
#'   [DESeqTransform] slotted inside the [bcbioRNADataSet].
#' @param use *Optional*. Character vector of columns to use.
#' @param ... Passthrough arguments to [DEGreport::degCovariates()].
#'
#' @return [ggplot].
#' @export
plot_pca_covariates <- function(bcb, transform = "rlog", use = NULL, ...) {
    metrics <- metrics(bcb)
    if (is.null(metrics)) return(NULL)

    # Get the columns of interest
    if (is.null(use)) {
        use <- colnames(metrics)
    } else {
        use <- intersect(use, colnames(metrics))
    }
    if (length(use) == 0L) {
        stop("Not columns matched between use and metadata")
    }

    keep_metrics <- lapply(use, function(a) {
        if (length(unique(metrics[, a])) > 1L) a
    }) %>%
        unlist %>%
        .[!is.null(.)]

    metrics <- metrics %>%
        as.data.frame %>%
        set_rownames(.[["description"]]) %>%
        .[, setdiff(keep_metrics, c("description", "file_name")), drop = FALSE]

    # Pass internal [DESeqTransform] to [degCovariates()]
    if (!transform %in% c("rlog", "vst")) {
        stop("DESeqTransform must be rlog or vst")
    }

    res <- assays(bcb)[[transform]] %>%
        # Assay needed here to get the matrix from [DESeqTransform]
        assay %>%
        degCovariates(metadata = metrics, ...)
    res %>%
        .[["plot"]] +
        theme(axis.text.x = element_text(angle = 60L, hjust = 1L))
    invisible(res)
}
