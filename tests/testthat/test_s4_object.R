context("S4 Object")



# bcbioRNASeq Constructor ==============================================
uploadDir <- system.file("extdata/bcbio", package = "bcbioRNASeq")
bcb <- suppressWarnings(bcbioRNASeq(
    uploadDir = uploadDir,
    organism = "Mus musculus",
    ensemblRelease = 87L
))
validObject(bcb)

test_that("bcbioRNASeq : GFF3 file", {
    # 87 is the oldest version supported by AnnotationHub
    # Note that gzip compression is supported for GFF/GTF files
    gffURL <- paste(
        "ftp://ftp.ensembl.org",
        "pub",
        "release-87",
        "gff3",
        "mus_musculus",
        "Mus_musculus.GRCm38.87.gff3.gz",
        sep = "/"
    )
    gffFile <- basename(gffURL)
    if (!file.exists(gffFile)) {
        download.file(url = gffURL, destfile = gffFile)
    }
    x <- bcbioRNASeq(
        uploadDir = uploadDir,
        organism = "Mus musculus",
        gffFile = gffFile
    )
})

test_that("bcbioRNASeq : GTF file", {
    gtfURL <- paste(
        "ftp://ftp.ensembl.org",
        "pub",
        "release-87",
        "gtf",
        "mus_musculus",
        "Mus_musculus.GRCm38.87.gtf.gz",
        sep = "/"
    )
    gtfFile <- basename(gtfURL)
    if (!file.exists(gtfFile)) {
        download.file(url = gtfURL, destfile = gtfFile)
    }
    x <- bcbioRNASeq(
        uploadDir = uploadDir,
        organism = "Mus musculus",
        gffFile = gtfFile
    )
})



# bcbioRNASeq Object ===========================================================
test_that("Slots", {
    expect_identical(
        slotNames(bcb),
        c(
            "rowRanges",
            "colData",
            "assays",
            "NAMES",
            "elementMetadata",
            "metadata"
        )
    )
    expect_identical(
        lapply(seq_along(slotNames(bcb)), function(a) {
            class(slot(bcb, slotNames(bcb)[[a]]))
        }),
        list(
            structure(
                "GRanges",
                package = "GenomicRanges"
            ),
            structure(
                "DataFrame",
                package = "S4Vectors"
            ),
            structure(
                "ShallowSimpleListAssays",
                package = "SummarizedExperiment"
            ),
            "NULL",  # character for SummarizedExperiment
            structure(
                "DataFrame",
                package = "S4Vectors"
            ),
            "list"
        )
    )
})

test_that("Dimensions", {
    expect_identical(
        dim(bcb),
        c(502L, 4L)
    )
    expect_identical(
        colnames(bcb),
        c("group1_1", "group1_2", "group2_1", "group2_2")
    )
    expect_identical(
        rownames(bcb)[1L:4L],
        c(
            "ENSMUSG00000002459",
            "ENSMUSG00000004768",
            "ENSMUSG00000005886",
            "ENSMUSG00000016918"
        )
    )
})

test_that("Assays", {
    # All assays should be a matrix
    expect_true(all(vapply(
        X = assays(bcb),
        FUN = function(assay) {
            is.matrix(assay)
        },
        FUN.VALUE = logical(1L)
    )))
})

test_that("Row data", {
    # Ensembl annotations from AnnotationHub, using ensembldb
    expect_identical(
        lapply(rowData(bcb), class),
        list(
            broadClass = "factor",
            description = "factor",
            entrezID = "list",
            geneBiotype = "factor",
            geneID = "character",
            geneName = "factor",
            seqCoordSystem = "factor"
        )
    )
})

test_that("Metadata", {
    tibble <- c("tbl_df", "tbl", "data.frame")
    expect_identical(
        lapply(metadata(bcb), class),
        list(
            version = c("package_version", "numeric_version"),
            level = "character",
            caller = "character",
            countsFromAbundance = "character",
            uploadDir = "character",
            sampleDirs = "character",
            sampleMetadataFile = "character",
            projectDir = "character",
            template = "character",
            runDate = "Date",
            interestingGroups = "character",
            organism = "character",
            genomeBuild = "character",
            ensemblRelease = "integer",
            rowRangesMetadata = tibble,
            gffFile = "character",
            "tx2gene" = "data.frame",
            lanes = "integer",
            yaml = "list",
            dataVersions = tibble,
            programVersions = tibble,
            bcbioLog = "character",
            bcbioCommandsLog = "character",
            allSamples = "logical",
            call = "call",
            date = "Date",
            wd = "character",
            utilsSessionInfo = "sessionInfo",
            devtoolsSessionInfo = "session_info"
        )
    )
    # Interesting groups should default to `sampleName`
    expect_identical(
        metadata(bcb)[["interestingGroups"]],
        "sampleName"
    )
})



# extract ======================================================================
test_that("extract : Normal gene and sample selection", {
    x <- bcb_small[seq_len(100L), seq_len(4L)]
    expect_s4_class(x, "bcbioRNASeq")
    expect_identical(dim(x), c(100L, 4L))
    expect_identical(
        rownames(x)[[1L]],
        rownames(bcb_small)[[1L]]
    )
    expect_identical(
        colnames(x),
        head(colnames(bcb_small), 4L)
    )
    expect_identical(
        names(assays(x)),
        c("counts", "tpm", "length", "normalized", "rlog", "vst")
    )
})

test_that("extract : Minimal selection ranges", {
    # Require at least 100 genes, 2 samples
    x <- bcb_small[seq_len(100L), seq_len(2L)]
    expect_error(bcb_small[seq_len(99L), ])
    expect_error(bcb_small[, seq_len(1L)])
    expect_identical(
        dimnames(x),
        list(
            head(rownames(bcb_small), 100L),
            head(colnames(bcb_small), 2L)
        )
    )
})



# bcbioRNASeq ==================================================================
test_that("bcbioRNASeq : organism = NULL", {
    x <- bcbioRNASeq(
        uploadDir = uploadDir,
        organism = NULL
    )
    expect_s4_class(x, "bcbioRNASeq")
    expect_identical(
        levels(seqnames(x)),
        "unknown"
    )
})

test_that("bcbioRNASeq : transformationLimit", {
    x <- suppressWarnings(
        bcbioRNASeq(
            uploadDir = uploadDir,
            organism = "Mus musculus",
            transformationLimit = -Inf
        )
    )
    expect_identical(
        names(assays(x)),
        c("counts", "tpm", "length", "normalized")
    )
})

test_that("bcbioRNASeq : User-defined sample metadata", {
    x <- suppressWarnings(bcbioRNASeq(
        uploadDir = uploadDir,
        organism = "Mus musculus",
        sampleMetadataFile = file.path(uploadDir, "sample_metadata.csv")
    ))
    expect_s4_class(x, "bcbioRNASeq")
    expect_identical(
        basename(metadata(x)[["sampleMetadataFile"]]),
        "sample_metadata.csv"
    )
})



# Extract method ===============================================================
test_that("extract : DESeq2 transforms", {
    # Transform by default
    x <- bcb_small[1:100, 1:2]
    expect_identical(
        names(assays(x)),
        c("counts", "tpm", "length", "normalized", "rlog", "vst")
    )

    # Allow the user to skip, using `transform` argument
    x <- bcb_small[1:100, 1:2, transform = FALSE]
    expect_identical(
        names(assays(x)),
        c("counts", "tpm", "length", "normalized")
    )
})



# show =========================================================================
test_that("show", {
    x <- capture.output(show(bcb_small))
    expect_true(grepl("bcbioRNASeq", x[[1L]]))
})



# updateObject =================================================================
test_that("updateObject", {
    expect_error(validObject(bcb_invalid))
    expect_identical(
        slot(bcb_invalid, "metadata")[["version"]],
        package_version("0.1.4")
    )
    organism <- slot(bcb_invalid, "metadata")[["organism"]]
    rowRanges <- makeGRangesFromEnsembl(organism, release = 87L)
    # Suppressing expected warning about ENSMUSG00000104475, ENSMUSG00000109048
    x <- suppressWarnings(updateObject(bcb_invalid, rowRanges = rowRanges))
    expect_identical(
        metadata(x)[["version"]],
        packageVersion
    )
    expect_identical(
        metadata(x)[["previousVersion"]],
        package_version("0.1.4")
    )
})
