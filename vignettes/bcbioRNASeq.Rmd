---
title: "bcbioRNASeq"
author: "Michael Steinbaugh and Lorena Pantano"
date: "`r BiocStyle::doc_date()`"
output: BiocStyle::html_document
bibliography: ../inst/rmarkdown/shared/bibliography.bib
vignette: >
  %\VignetteIndexEntry{bcbioRNASeq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
abstract: >
  RNA-seq analysis involves multiple steps from processing raw sequencing data
  to identifying, organizing, annotating, and reporting differentially expressed
  genes. bcbio is an open source, community-maintained framework providing
  automated and scalable RNA-seq methods for identifying gene abundance counts.
  We have developed bcbioRNASeq, a Bioconductor package that provides
  ready-to-render templates and wrapper functions to post-process bcbio output
  data. bcbioRNASeq automates the generation of high-level RNA-seq reports,
  including identification of differentially expressed genes, functional
  enrichment analysis and quality control analysis.
---

```{r setup, include=FALSE, message=FALSE}
devtools::load_all()
ggplot2::theme_set(theme_paperwhite())
knitr::opts_chunk[["set"]](
    fig.height = 10L,
    fig.width = 10L
)
```

For a high-level overview of our [bcbio][] RNA-seq analysis pipeline, including detailed explanation of the `bcbioRNASeq` S4 class definition, first consult our [workflow paper][] published in *F1000 Research*. This vignette is focused on more advanced usage and edge cases that a user may encounter when attempting to load a [bcbio][] dataset and perform downstream quality control analysis.

**Note:** if you use [bcbioRNASeq][] in published research, please include this citation:

```{r}
citation("bcbioRNASeq")
```

* * *

# Loading [bcbio][] data

The `bcbioRNASeq()` constructor function is the main interface connecting [bcbio][] output data to interactive use in [R][]. It is highly customizable and supports a number of options for advanced use cases. Consult the documentation available at `help(topic = "bcbioRNASeq", package = "bcbioRNASeq")` for additional details.

```{r formals}
formals("bcbioRNASeq") %>% str()
```

## Upload directory

We have designed the constructor to work as simply as possible by default. The only required argument is `uploadDir`, the path to the [bcbio][] final upload directory specified with `upload:` in the YAML configuration. Refer to the [bcbio configuration](https://bcbio-nextgen.readthedocs.io/en/latest/contents/configuration.html) documentation for detailed information on how to set up a [bcbio][] run, which is outside the scope of this vignette.

For example, let's load up the example [bcbio][] dataset stored internally in the package.

```{r}
upload_dir <- system.file("extdata/bcbio", package = "bcbioRNASeq")
stopifnot(file.exists(upload_dir))
print(upload_dir)
```

[bcbio][] outputs RNA-seq data in a standardized directory structure, which is described in detail in our [workflow paper][].

```{r}
dir(path = upload_dir, full.names = FALSE, recursive = TRUE)
```

## Counts level

By default, [bcbioRNASeq][] imports counts at gene level, which are required for standard differential expression analysis (`level = "genes"`). For pseudo-aligned counts (e.g. [Salmon][], [Kallisto][], [Sailfish][]) [@Salmon, @Kallisto, @Sailfish], [tximport][] [@tximport] is used internally to aggregate transcript-level counts to gene-level counts, and generates length-scaled transcripts per million (TPM) values. For aligned counts processed with [featureCounts][] [@featureCounts] (e.g. [STAR][], [HISAT2][]) [@STAR; @HISAT2], these values are already returned at gene level, and therefore not handled by [tximport][]. Once the gene-level counts are imported during the `bcbioRNASeq()` call, the [DESeq2][] package [@DESeq2] is then used to generate an internal `DESeqDataSet` from which we derive normalized and variance-stabilized counts.

```{r, warning=FALSE}
bcb <- bcbioRNASeq(uploadDir = upload_dir, level = "genes")
print(bcb)
```

Alternatively, if you want to perform transcript-aware analysis, such as differential exon usage or splicing analysis, transcript-level counts can be obtained using `level = "transcripts"`. Note that when counts are loaded at transcript level, TPMs are generated with [tximport][] internally, but no additional normalizations or transformations normally calculated for gene-level counts with [DESeq2][] are generated.

```{r, warning=FALSE}
bcb <- bcbioRNASeq(uploadDir = upload_dir, level = "transcripts")
print(bcb)
```

## Expression callers

Since [bcbio][] is flexible and supports a number of expression callers, we have provided advanced options in the `bcbioRNASeq()` constructor to support a variety of workflows using the `caller` argument.

Salmon, Kallisto, and Sailfish counts are supported at either gene or transcript level. Internally, these are loaded using [tximport][] [@tximport].

```{r, warning=FALSE}
salmon_genes <- bcbioRNASeq(uploadDir = upload_dir, caller = "salmon")
print(salmon_genes)
assayNames(salmon_genes)
```

```{r, warning=FALSE}
salmon_tx <- bcbioRNASeq(uploadDir = upload_dir, level = "transcripts")
print(salmon_tx)
assayNames(salmon_tx)
```

[STAR][] and [HISAT2][] [@STAR; @HISAT2] aligned counts processed with [featureCounts][] [@featureCounts] are also supported, but only at gene level.

```{r, warning=FALSE}
star <- bcbioRNASeq(uploadDir = upload_dir, caller = "star")
print(star)
assayNames(star)
```

## Sample selection and metadata

If you'd like to load up only a subset of samples, this can be done easily using the `samples` argument. Note that the `character` vector declared here must match the `description` column specified in the sample metadata. For example, let's create a `bcbioRNASeq` object containing only the `group1_1` and `group1_2` samples.

```{r, warning=FALSE}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    samples = c("group1_1", "group1_2")
)
print(bcb)
sampleNames(bcb)
```

Conversely, if you're working with a large dataset and you simply want to drop a few samples, this can be accomplished with the `censorSamples` argument. Note that the `samples` argument takes priority if both are declared. For example, let's drop the `group2_2` sample from our minimal dataset.

```{r, warning=FALSE}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    censorSamples = "group2_2"
)
print(bcb)
sampleNames(bcb)
```

If you're working with a bcbio run that has incorrect or outdated metadata, the simplest way to fix this issue is to pass in new metadata from an external spreadsheet (CSV or Excel) using the `sampleMetadataFile` argument. Note that this can also be used to subset the bcbio dataset, similar to the `samples` argument (see above), based on the rows that are included in the spreadsheet.

```{r}
sample_metadata_file <- file.path(upload_dir, "sample_metadata.csv")
stopifnot(file.exists(sample_metadata_file))
readSampleData(sample_metadata_file)
```

```{r, warning=FALSE}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    sampleMetadataFile = sample_metadata_file
)
print(bcb)
sampleData(bcb, clean = TRUE)
```

## Genome annotations

When analyzing a dataset against a well-annotated genome, we recommend importing the corresponding metadata using [AnnotationHub][] and [ensembldb][] [@AnnotationHub; @ensembldb]. This functionality is natively supported in the `bcbioRNASeq()` constructor with using the `organism`, `ensemblRelease`, and `genomeBuild` arguments. This will return a `GRanges` object using the [GenomicRanges][] package [@GenomicRanges], which contains coordinates and rich metadata for each gene or transcript. These annotations are accessible with the `rowRanges()` and `rowData()` functions defined in the [SummarizedExperiment][] package [@SummarizedExperiment].

For example, with our internal [bcbio][] dataset, we're analyzing counts generated against the [Ensembl][] *Mus musculus* GRCm38 genome build (release 87). These parameters can be defined in the object load call to ensure that the annotations match up exactly with the genome used.

```{r}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    level = "genes",
    organism = "Mus musculus",
    genomeBuild = "GRCm38",
    ensemblRelease = 87
)
print(bcb)
metadata(bcb)$rowRangesMetadata
rowRanges(bcb) %>% as.data.frame() %>% glimpse()
```

Alternatively, transcript-level annotations can also be obtained automatically using this method.

```{r}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    level = "transcripts",
    organism = "Mus musculus",
    genomeBuild = "GRCm38",
    ensemblRelease = 87
)
print(bcb)
rowRanges(bcb) %>% as.data.frame() %>% glimpse()
```

When working with a dataset generated against a poorly-annotated or non-standard genome, we provide a fallback method for loading gene annotations from a [general feature format (GFF)][GFF] file with the `gffFile` argument. If possible, we recommend providing a general transfer format (GTF) file, which is identical to GFF version 2. GFFv3 is more complicated and non-standard, but [Ensembl][] GFFv3 files are also supported.

```{r}
gff_url <- paste(
    "ftp://ftp.ensembl.org",
    "pub",
    "release-87",
    "gtf",
    "mus_musculus",
    "Mus_musculus.GRCm38.87.gtf.gz",
    sep = "/"
)
gff_file <- basename(gff_url)
if (!file.exists(gff_file)) {
    download.file(url = gff_url, destfile = gff_file)
}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    organism = "Mus musculus",
    gffFile = gff_file
)
print(bcb)
rowRanges(bcb) %>% as.data.frame() %>% glimpse()
```

If your dataset contains transgenes (e.g. EGFP, TDTOMATO) or spike-ins (e.g. ERCCs), these features can be defined with the `transgeneNames` and `spikeNames` arguments, which will automatically populate the `rowRanges()` slot with placeholder metadata.

We recommend loading up data per genome in its own `bcbioRNASeq` object when possible, so that rich metadata can be imported easily. In the edge case where you need to look at multiple genomes simultaneously, set `organism = NULL`, and bcbioRNASeq will skip the gene annotation acquisition step.

```{r, warning=FALSE}
bcb <- bcbioRNASeq(uploadDir = upload_dir, organism = NULL)
print(bcb)
```

## Variance stabilization

During the `bcbioRNASeq()` constructor call, variance stabilizaton of gene-level counts can be calculated automatically, and is recommended. This is performed internally by the [DESeq2][] package. These transformations will be slotted into `assays()` as `vst` and/or `rlog` matrices. The `vst` matrix is calculated by [DESeq2::varianceStabilizingTransformation()] and `rlog` by [DESeq2::rlog()]. For large datasets, `rlog` calculation can take a long time, so we are currently recommending calculation of only `vst` by default.

```{r, warning=FALSE}
bcb <- bcbioRNASeq(
    uploadDir = upload_dir,
    vst = TRUE,
    rlog = TRUE
)
assayNames(bcb)
counts(bcb, normalized = "vst") %>% summary()
counts(bcb, normalized = "rlog") %>% summary()
```

* * *

# Use case dataset

To demonstrate the functionality and configuration of the package, we have taken an experiment from the [Gene Expression Omnibus (GEO)][GEO] public repository of expression data to use as an example use case. The RNA-seq data is from a study of acute kidney injury in a mouse model ([GSE65267](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE65267)) [@Craciun2016]. The study aims to identify differentially expressed genes in progressive kidney fibrosis and contains samples from mouse kidneys at several time points (n = 3, per time point) after folic acid treatment. From this dataset, we are using a subset of the samples for our use case: before folic acid treatment, and 1, 3, 7 days after treatment.

For the vignette, we are loading a pre-computed version of the example `bcbioRNASeq` object used in our [workflow paper][].

```{r}
rm(bcb)
loadRemoteData("https://github.com/hbc/bcbioRNASeq/raw/f1000v2/data/bcb.rda")
```

# Sample metadata

For reference, let's take a look at the sample metadata. By comparison, using `colData()` will return all sample-level metadata, including our quality control metrics generated by bcbio. We recommend instead using `sampleData()` with the `clean = TRUE` argument in reports, which only returns `factor` columns of interest.

```{r}
sampleData(bcb, clean = TRUE)
```

# Interesting groups

Groups of interest to be used for coloring and sample grouping in the quality control plots can be defined in the `bcbioRNASeq` object using the `interestingGroups` argument in the `bcbioRNASeq()` constructor call. Assignment method support with the `interestingGroups()` function is also provided, which can modify the groups of interest after the object has been created.

The `interestingGroups` definition defaults to `sampleName`, which is automatically generated from the [bcbio][] `description` metadata for demultiplexed bulk RNA-seq samples. In this case, the samples will be grouped and colored uniquely.

Interesting groups must be defined using a `character` vector and refer to column names defined in the `colData()` slot of the object. Note that the [bcbioRNASeq][] packages uses lower camel case formatting for column names (e.g. "sampleName"), so the interesting groups should be defined using camel case, not snake (e.g. "sample_name") or dotted case (e.g. "sample.name").

This approach was inspired by the [DESeq2][] [@DESeq2] package, which uses the argument `intgroup` in some functions, such as `plotPCA()` for labeling groups of interest. We took this idea and ran with it for a number of our quality control functions, which are described in detail below.

```{r}
interestingGroups(bcb) <- c("treatment", "day")
interestingGroups(bcb)
```

# Quality control plots

Our [workflow paper][] describes our quality control process in detail. In addition, our **Quality Control** [R Markdown][] contains notes detailing each metric. Here were are going into more technical detail regarding how to customize the appearance of the plots. Note that all quality control plotting functions inherit the `interestingGroups` defined inside the `bcbioRNASeq` object. You can also change this dynamially for each function call using the `interestingGroups` argument.

## Read counts

```{r}
plotTotalReads(bcb)
plotMappedReads(bcb)
```

## Mapping rates

Note that the overall mapping rate is relatively low per sample, while the exonic mapping rate is acceptable. High quality samples should have low intronic mapping rate, and high values are indicative of sample degradation and/or contamination.

```{r}
plotMappingRate(bcb)
plotExonicMappingRate(bcb)
plotIntronicMappingRate(bcb)
```

## rRNA mapping rate

Note that the samples here have a high rRNA mapping rate. This can be indicative of the polyA enrichment or ribo depletion protocol not having removed all ribosomal RNA (rRNA) transcripts. This will reduce the number of biologically meaningful reads in the experiment and is best avoided.

```{r}
plotRRNAMappingRate(bcb)
```

## 5'->3' bias

RNA-seq data can have specific biases at either the 5’ or 3’ end of sequenced fragments. It is common to see a small amount of bias, especially if polyA enrichment was performed, or if there is any sample degradation. If a large amount of bias is observed here, be sure to analyze the samples with a Bioanalyzer and check the RIN scores.

```{r}
plot5Prime3PrimeBias(bcb)
```

## Gene distributions

```{r}
plotGenesDetected(bcb)
```

```{r}
plotGeneSaturation(bcb, label = FALSE)
plotGeneSaturation(bcb, label = TRUE)
```

```{r}
plotCountsPerGene(bcb)
```

```{r}
plotCountDensity(
    object = bcb,
    interestingGroups = "sampleName",
    style = "line"
)
plotCountDensity(bcb, style = "solid")
```

## Dispersion

The following plot shows the dispersion by mean of normalized counts. We expect the dispersion to decrease as the mean of normalized counts increases.

```{r}
plotDispEsts(bcb)
```

## Variance stabilization

These plots show the standard deviation of normalized counts using `log2()`, `varianceStabilizingTransform()`, `rlog()`, and `tmm()` by `rank(mean)`. Note that all counts shown are log2 scale.

```{r}
plotMeanSD(bcb)
```

## Sample similarity

We can visualize sample similarity with principal component analysis (PCA) and hierarchical clustering of sample correlations. These functions support multiple normalization methods with the `normalized` argument. We recommend using `normalized = "vst"` by default.

Let's plot the PCA using our `vst` counts, the current recommended default.

```{r}
plotPCA(bcb, normalized = "vst", label = FALSE)
plotPCA(bcb, normalized = "vst", label = TRUE)
```

Let's visualize the `rlog` counts for comparison. The performance is similar overall, with some slight differences, but the grouping more or less remains the same.

```{r}
plotPCA(
    object = bcb,
    normalized = "rlog",
    label = FALSE
)
plotPCA(
    object = bcb,
    normalized = "rlog",
    label = TRUE
)
```

Generally, the `varianceStabilizationTransformation()` and `rlog()` functions provide similar performance, as seen here.

```{r}
plotCorrelationHeatmap(
    bcb,
    method = "pearson",
    normalized = "vst",
    color = viridis
)
plotCorrelationHeatmap(
    bcb,
    method = "spearman",
    normalized = "vst",
    color = plasma
)
```

```{r}
plotCorrelationHeatmap(
    object = bcb,
    method = "pearson",
    normalized = "rlog",
    color = viridis
)
plotCorrelationHeatmap(
    object = bcb,
    method = "spearman",
    normalized = "rlog",
    color = plasma
)
```

# Counts

The `counts()` function returns the abundance estimates generated by Salmon. Read counts for each sample in the dataset are aggregated into a matrix, in which columns correspond to samples and rows represent genes. Multiple normalized counts matrices are saved in the bcbioRNASeq object, and are accessible with `normalized` argument:

- `FALSE`: Raw counts (*default*).
- `TRUE`: [DESeq2][] normalized counts.
- `"tpm"`: Transcripts per million.
- `"tmm"`: Trimmed mean of M-values normalization method.
- `"vst"`: Variance stabilization transformation.
- `"rlog"`: Regularized log transformation.
- `"rle"`: Relative log expression transformation.

## Exporting quantified data

Were recommend saving the raw counts, normalized counts, TPMs, and variance-stabilized counts to disk both in binary R Data and CSV formats.

```{r}
raw <- counts(bcb, normalized = FALSE)
normalized <- counts(bcb, normalized = TRUE)
tpm <- counts(bcb, normalized = "tpm")
vst <- counts(bcb, normalized = "vst")
saveData(raw, normalized, tpm, vst, dir = ".")
writeCounts(raw, normalized, tpm, vst, dir = ".")
```

# Differential expression

[bcbioRNASeq][] integrates with the [DESeq2][] package [@DESeq2], which we recommend for differential expression. To prepare our dataset for differential expression, we need to coerce the `bcbioRNASeq` object to a `DESeqDataSet`. Use the `as()` function.

```{r}
dds <- as(bcb, "DESeqDataSet")
print(dds)
```

Since both `bcbioRNASeq` and `DESeqDataSet` S4 classes extend `RangedSummarizedExperiment`, internally we coerce the original `bcbioRNASeq` object to a `RangedSummarizedExperiment` and then use the `DESeqDataSet()` constructor, which requires a `SummarizedExperiment` with integer counts.

```{r}
getMethod(
    f = "coerce",
    signature(
        from = "bcbioRNASeq",
        to = "DESeqDataSet"
    )
)
```

Now you can perform differential expression analysis with [DESeq2][]. The authors of that package have provided a number of detailed, well documented references online:

- [Analyzing RNA-seq data with DESeq2](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html).
- [RNA-Seq workflow: gene-level exploratory analysis and differential expression](http://dx.doi.org/10.12688/f1000research.7035.2).
- [Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences](https://f1000research.com/articles/4-1521/v2).

We provide a parameterized [R Markdown][] template for standard [DESeq2][] differential expression, supporting analysis and visualization of multiple contrasts inside a single report. We describe an example approach for LRT analysis inside our [workflow paper][], and more advanced edge-case templates are available inside our [hbcABC][] package, which is a work in progress.

# Functional analysis

We provide an [R Markdown][] template for [gene set enrichment analysis (GSEA)][] [@GSEA] and [Kyoto Encyclopedia of Genes and Genomes (KEGG)][KEGG] [@KEGG] pathway enrichment analysis, which leverages the functionality of the [clusterProfiler][] package. This workflow is described in detail in our [workflow paper][], and is outside the scope of this advanced use vignette. For more information on functional analysis, consult the [clusterProfiler][] vignette, which is extremely detailed and thorough.

# [R][] session information

```{r}
sessionInfo()
```

[bcbio]: https://bcbio-nextgen.readthedocs.io
[bcbioRNASeq]: http://bioinformatics.sph.harvard.edu/bcbioRNASeq
[clusterProfiler]: https://doi.org/doi:10.18129/B9.bioc.clusterProfiler
[DESeq2]: https://doi.org/doi:10.18129/B9.bioc.DESeq2
[Ensembl]: https://www.ensembl.org
[GFF]: https://useast.ensembl.org/info/website/upload/gff.html
[GEO]: https://www.ncbi.nlm.nih.gov/geo
[hbcABC]: https://github.com/hbc/hbcABC
[KEGG]: https://www.genome.jp/kegg
[R]: https://www.r-project.org
[tximport]: https://doi.org/doi:10.18129/B9.bioc.tximport
[workflow paper]: http://dx.doi.org/10.12688/f1000research.12093.2
